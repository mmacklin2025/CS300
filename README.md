# CS300

In Project One, I analyzed the efficiency of different data structures in terms of run-time and memory usage. The goal was to determine which structure were the most appropriate for specific tasks. In Project Two, I implemented a program that reads course data and outputs a sorted list of Computer Science courses, focusing on algorithmic correctness and efficiency. 

I began by identifying the requirements of each task and selecting data structures that best aligned with those needs. For example, I used hash tables for fast lookups and binary search trees for sorted output. Understanding the trade-offs between structures such as access time vs memory useage was crucial in making informed decisions. 

I encountered challenges with debugging and ensuring that my sorting algorithm handled edge cases correctly. I overcame these by writing modular code, using pseudocode to clarify logic, and testing with varied input data. I also leaned on Agile principles, breaking the problem into smaller tasks and iterating through solutions. 

These projects reinforced the importance of planning and choosing the right tools for the job. I now approach software design with a deeper appreciation for how foundational structures impact performance and scalability. I've also become more intentional about documenting my thought process and testing it thoroughly. 

I've adopted clearer naming conventions, modular design, and consistent formatting to improve readability. I've also started writing more adaptable code by anticipating future changes such as adding new data types or modifying sorting criteria, and designing with flexibility in mind. These habits make my code easier to maintain and collaborate on.
